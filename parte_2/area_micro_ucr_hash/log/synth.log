Qflow synthesis logfile created on dom 25 jul 23:36:08 CST 2021
Running yosys for verilog parsing and synthesis
yosys  -s micro_ucr_hash.ys

 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9 (git sha1 1979e0b)


-- Executing script file `micro_ucr_hash.ys' --

1. Executing Liberty frontend.
Imported 32 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/source/micro_ucr_hash.v
Parsing Verilog input from `/home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/source/micro_ucr_hash.v' to AST representation.
Generating RTLIL representation for module `\cargar_datos'.
modulos.v:25: Warning: Range [159:32] select out of bounds on signal `\bloque': Setting 32 MSB bits to undef.
modulos.v:25: Warning: Range [159:32] select out of bounds on signal `\bloque': Setting 32 MSB bits to undef.
Generating RTLIL representation for module `\generar_W'.
Generating RTLIL representation for module `\algo_hash'.
Generating RTLIL representation for module `\comparador_target_hash'.
Generating RTLIL representation for module `\micro_ucr_hash'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \micro_ucr_hash
Used module:     \comparador_target_hash
Used module:     \algo_hash
Used module:     \generar_W
Used module:     \cargar_datos

3.1.2. Analyzing design hierarchy..
Top module:  \micro_ucr_hash
Used module:     \comparador_target_hash
Used module:     \algo_hash
Used module:     \generar_W
Used module:     \cargar_datos
Removed 0 unused modules.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 47 empty switches in `\algo_hash.$proc$modulos.v:54$103'.
Cleaned up 47 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$modulos.v:96$267 in module comparador_target_hash.
Marked 1 switch rules as full_case in process $proc$modulos.v:13$1 in module cargar_datos.
Removed a total of 0 dead cases.

3.2.3. Executing PROC_INIT pass (extract init attributes).

3.2.4. Executing PROC_ARST pass (detect async resets in processes).

3.2.5. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\comparador_target_hash.$proc$modulos.v:96$267'.
     1/4: $1\bounty[23:0]
     2/4: $1\terminado[0:0]
     3/4: $0\terminado[0:0]
     4/4: $0\bounty[23:0]
Creating decoders for process `\algo_hash.$proc$modulos.v:54$103'.
     1/106: $47\x_[7:0]
     2/106: $47\k[7:0]
     3/106: $46\x_[7:0]
     4/106: $46\k[7:0]
     5/106: $45\x_[7:0]
     6/106: $45\k[7:0]
     7/106: $44\x_[7:0]
     8/106: $44\k[7:0]
     9/106: $43\x_[7:0]
    10/106: $43\k[7:0]
    11/106: $42\x_[7:0]
    12/106: $42\k[7:0]
    13/106: $41\x_[7:0]
    14/106: $41\k[7:0]
    15/106: $40\x_[7:0]
    16/106: $40\k[7:0]
    17/106: $39\x_[7:0]
    18/106: $39\k[7:0]
    19/106: $38\x_[7:0]
    20/106: $38\k[7:0]
    21/106: $37\x_[7:0]
    22/106: $37\k[7:0]
    23/106: $36\x_[7:0]
    24/106: $36\k[7:0]
    25/106: $35\x_[7:0]
    26/106: $35\k[7:0]
    27/106: $34\x_[7:0]
    28/106: $34\k[7:0]
    29/106: $33\x_[7:0]
    30/106: $33\k[7:0]
    31/106: $32\x_[7:0]
    32/106: $32\k[7:0]
    33/106: $31\x_[7:0]
    34/106: $31\k[7:0]
    35/106: $30\x_[7:0]
    36/106: $30\k[7:0]
    37/106: $29\x_[7:0]
    38/106: $29\k[7:0]
    39/106: $28\x_[7:0]
    40/106: $28\k[7:0]
    41/106: $27\x_[7:0]
    42/106: $27\k[7:0]
    43/106: $26\x_[7:0]
    44/106: $26\k[7:0]
    45/106: $25\x_[7:0]
    46/106: $25\k[7:0]
    47/106: $24\x_[7:0]
    48/106: $24\k[7:0]
    49/106: $23\x_[7:0]
    50/106: $23\k[7:0]
    51/106: $22\x_[7:0]
    52/106: $22\k[7:0]
    53/106: $21\x_[7:0]
    54/106: $21\k[7:0]
    55/106: $20\x_[7:0]
    56/106: $20\k[7:0]
    57/106: $19\x_[7:0]
    58/106: $19\k[7:0]
    59/106: $18\x_[7:0]
    60/106: $18\k[7:0]
    61/106: $17\x_[7:0]
    62/106: $17\k[7:0]
    63/106: $16\x_[7:0]
    64/106: $16\k[7:0]
    65/106: $15\x_[7:0]
    66/106: $15\k[7:0]
    67/106: $14\x_[7:0]
    68/106: $14\k[7:0]
    69/106: $13\x_[7:0]
    70/106: $13\k[7:0]
    71/106: $12\x_[7:0]
    72/106: $12\k[7:0]
    73/106: $11\x_[7:0]
    74/106: $11\k[7:0]
    75/106: $10\x_[7:0]
    76/106: $10\k[7:0]
    77/106: $9\x_[7:0]
    78/106: $9\k[7:0]
    79/106: $8\x_[7:0]
    80/106: $8\k[7:0]
    81/106: $7\x_[7:0]
    82/106: $7\k[7:0]
    83/106: $6\x_[7:0]
    84/106: $6\k[7:0]
    85/106: $5\x_[7:0]
    86/106: $5\k[7:0]
    87/106: $4\x_[7:0]
    88/106: $4\k[7:0]
    89/106: $3\x_[7:0]
    90/106: $3\k[7:0]
    91/106: $2\x_[7:0]
    92/106: $2\k[7:0]
    93/106: $1\x_[7:0]
    94/106: $1\k[7:0]
    95/106: $0\H[23:0] [23:16]
    96/106: $0\H[23:0] [15:8]
    97/106: $0\H[23:0] [7:0]
    98/106: $0\i[31:0]
    99/106: $0\c[7:0]
   100/106: $0\b[7:0]
   101/106: $0\a[7:0]
   102/106: $0\x_[7:0]
   103/106: $0\k[7:0]
   104/106: $0\H_int[23:0] [23:16]
   105/106: $0\H_int[23:0] [15:8]
   106/106: $0\H_int[23:0] [7:0]
Creating decoders for process `\generar_W.$proc$modulos.v:35$38'.
     1/33: $0\i[31:0]
     2/33: $0\W[255:0] [255:248]
     3/33: $0\W[255:0] [247:240]
     4/33: $0\W[255:0] [239:232]
     5/33: $0\W[255:0] [231:224]
     6/33: $0\W[255:0] [223:216]
     7/33: $0\W[255:0] [215:208]
     8/33: $0\W[255:0] [207:200]
     9/33: $0\W[255:0] [199:192]
    10/33: $0\W[255:0] [191:184]
    11/33: $0\W[255:0] [183:176]
    12/33: $0\W[255:0] [175:168]
    13/33: $0\W[255:0] [167:160]
    14/33: $0\W[255:0] [159:152]
    15/33: $0\W[255:0] [151:144]
    16/33: $0\W[255:0] [143:136]
    17/33: $0\W[255:0] [135:128]
    18/33: $0\W[255:0] [127:120]
    19/33: $0\W[255:0] [119:112]
    20/33: $0\W[255:0] [111:104]
    21/33: $0\W[255:0] [103:96]
    22/33: $0\W[255:0] [95:88]
    23/33: $0\W[255:0] [87:80]
    24/33: $0\W[255:0] [79:72]
    25/33: $0\W[255:0] [71:64]
    26/33: $0\W[255:0] [63:56]
    27/33: $0\W[255:0] [55:48]
    28/33: $0\W[255:0] [47:40]
    29/33: $0\W[255:0] [39:32]
    30/33: $0\W[255:0] [31:24]
    31/33: $0\W[255:0] [23:16]
    32/33: $0\W[255:0] [15:8]
    33/33: $0\W[255:0] [7:0]
Creating decoders for process `\cargar_datos.$proc$modulos.v:23$5'.
     1/2: $0\bloque[127:0] [127:32]
     2/2: $0\bloque[127:0] [31:0]
Creating decoders for process `\cargar_datos.$proc$modulos.v:13$1'.
     1/1: $0\nonce[31:0]

3.2.6. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\comparador_target_hash.\bounty' from process `\comparador_target_hash.$proc$modulos.v:96$267'.
No latch inferred for signal `\comparador_target_hash.\terminado' from process `\comparador_target_hash.$proc$modulos.v:96$267'.
No latch inferred for signal `\algo_hash.\H' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\i' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\H_int' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\a' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\b' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\c' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\k' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\algo_hash.\x_' from process `\algo_hash.$proc$modulos.v:54$103'.
No latch inferred for signal `\generar_W.\W' from process `\generar_W.$proc$modulos.v:35$38'.
No latch inferred for signal `\generar_W.\i' from process `\generar_W.$proc$modulos.v:35$38'.
No latch inferred for signal `\cargar_datos.\bloque' from process `\cargar_datos.$proc$modulos.v:23$5'.

3.2.7. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\cargar_datos.\nonce' using process `\cargar_datos.$proc$modulos.v:13$1'.
  created $dff cell `$procdff$282' with positive edge clock.

3.2.8. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\comparador_target_hash.$proc$modulos.v:96$267'.
Removing empty process `comparador_target_hash.$proc$modulos.v:96$267'.
Removing empty process `algo_hash.$proc$modulos.v:54$103'.
Removing empty process `generar_W.$proc$modulos.v:35$38'.
Removing empty process `cargar_datos.$proc$modulos.v:23$5'.
Found and cleaned up 2 empty switches in `\cargar_datos.$proc$modulos.v:13$1'.
Removing empty process `cargar_datos.$proc$modulos.v:13$1'.
Cleaned up 3 empty switches.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module micro_ucr_hash.
Optimizing module comparador_target_hash.
Optimizing module algo_hash.
<suppressed ~37 debug messages>
Optimizing module generar_W.
Optimizing module cargar_datos.
<suppressed ~1 debug messages>

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \micro_ucr_hash..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \cargar_datos..
Removed 1 unused cells and 177 unused wires.
<suppressed ~6 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
checking module algo_hash..
checking module cargar_datos..
checking module comparador_target_hash..
checking module generar_W..
checking module micro_ucr_hash..
Warning: Wire micro_ucr_hash.\bounty [123] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [122] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [121] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [120] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [119] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [118] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [117] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [116] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [115] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [114] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [113] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [112] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [111] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [110] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [109] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [108] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [107] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [106] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [105] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [104] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [103] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [102] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [101] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [100] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [99] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [98] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [97] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [96] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [95] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [94] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [93] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [92] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [91] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [90] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [89] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [88] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [87] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [86] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [85] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [84] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [83] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [82] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [81] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [80] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [79] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [78] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [77] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [76] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [75] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [74] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [73] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [72] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [71] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [70] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [69] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [68] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [67] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [66] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [65] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [64] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [63] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [62] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [61] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [60] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [59] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [58] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [57] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [56] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [55] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [54] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [53] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [52] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [51] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [50] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [49] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [48] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [47] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [46] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [45] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [44] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [43] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [42] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [41] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [40] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [39] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [38] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [37] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [36] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [35] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [34] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [33] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [32] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [31] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [30] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [29] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [28] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [27] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [26] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [25] is used but has no driver.
Warning: Wire micro_ucr_hash.\bounty [24] is used but has no driver.
found and reported 100 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \algo_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cargar_datos..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparador_target_hash..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \generar_W..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \micro_ucr_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \algo_hash.
  Optimizing cells in module \cargar_datos.
  Optimizing cells in module \comparador_target_hash.
  Optimizing cells in module \generar_W.
  Optimizing cells in module \micro_ucr_hash.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.6.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.6.9. Finished OPT passes. (There is nothing left to do.)

3.7. Executing WREDUCE pass (reducing word size of cells).
Removed top 2 bits (of 8) from port A of cell algo_hash.$add$modulos.v:78$108 ($add).
Removed top 2 bits (of 8) from port A of cell algo_hash.$add$modulos.v:78$113 ($add).
Removed top 7 bits (of 8) from port A of cell algo_hash.$add$modulos.v:81$264 ($add).
Removed top 31 bits (of 32) from port B of cell cargar_datos.$add$modulos.v:19$4 ($add).

3.8. Executing PEEPOPT pass (run peephole optimizers).

3.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.10. Executing TECHMAP pass (map to technology primitives).

3.10.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

3.10.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~40 debug messages>

3.11. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module algo_hash:
  creating $macc model for $add$modulos.v:78$108 ($add).
  creating $macc model for $add$modulos.v:78$113 ($add).
  creating $macc model for $add$modulos.v:78$117 ($add).
  creating $macc model for $add$modulos.v:78$118 ($add).
  creating $macc model for $add$modulos.v:78$122 ($add).
  creating $macc model for $add$modulos.v:78$123 ($add).
  creating $macc model for $add$modulos.v:78$127 ($add).
  creating $macc model for $add$modulos.v:78$128 ($add).
  creating $macc model for $add$modulos.v:78$132 ($add).
  creating $macc model for $add$modulos.v:78$133 ($add).
  creating $macc model for $add$modulos.v:78$137 ($add).
  creating $macc model for $add$modulos.v:78$138 ($add).
  creating $macc model for $add$modulos.v:78$142 ($add).
  creating $macc model for $add$modulos.v:78$143 ($add).
  creating $macc model for $add$modulos.v:78$147 ($add).
  creating $macc model for $add$modulos.v:78$148 ($add).
  creating $macc model for $add$modulos.v:78$152 ($add).
  creating $macc model for $add$modulos.v:78$153 ($add).
  creating $macc model for $add$modulos.v:78$157 ($add).
  creating $macc model for $add$modulos.v:78$158 ($add).
  creating $macc model for $add$modulos.v:78$162 ($add).
  creating $macc model for $add$modulos.v:78$163 ($add).
  creating $macc model for $add$modulos.v:78$167 ($add).
  creating $macc model for $add$modulos.v:78$168 ($add).
  creating $macc model for $add$modulos.v:78$172 ($add).
  creating $macc model for $add$modulos.v:78$173 ($add).
  creating $macc model for $add$modulos.v:78$177 ($add).
  creating $macc model for $add$modulos.v:78$178 ($add).
  creating $macc model for $add$modulos.v:78$182 ($add).
  creating $macc model for $add$modulos.v:78$183 ($add).
  creating $macc model for $add$modulos.v:78$187 ($add).
  creating $macc model for $add$modulos.v:78$188 ($add).
  creating $macc model for $add$modulos.v:78$192 ($add).
  creating $macc model for $add$modulos.v:78$193 ($add).
  creating $macc model for $add$modulos.v:78$197 ($add).
  creating $macc model for $add$modulos.v:78$198 ($add).
  creating $macc model for $add$modulos.v:78$202 ($add).
  creating $macc model for $add$modulos.v:78$203 ($add).
  creating $macc model for $add$modulos.v:78$207 ($add).
  creating $macc model for $add$modulos.v:78$208 ($add).
  creating $macc model for $add$modulos.v:78$212 ($add).
  creating $macc model for $add$modulos.v:78$213 ($add).
  creating $macc model for $add$modulos.v:78$217 ($add).
  creating $macc model for $add$modulos.v:78$218 ($add).
  creating $macc model for $add$modulos.v:78$222 ($add).
  creating $macc model for $add$modulos.v:78$223 ($add).
  creating $macc model for $add$modulos.v:78$227 ($add).
  creating $macc model for $add$modulos.v:78$228 ($add).
  creating $macc model for $add$modulos.v:78$232 ($add).
  creating $macc model for $add$modulos.v:78$233 ($add).
  creating $macc model for $add$modulos.v:78$237 ($add).
  creating $macc model for $add$modulos.v:78$238 ($add).
  creating $macc model for $add$modulos.v:78$242 ($add).
  creating $macc model for $add$modulos.v:78$243 ($add).
  creating $macc model for $add$modulos.v:78$247 ($add).
  creating $macc model for $add$modulos.v:78$248 ($add).
  creating $macc model for $add$modulos.v:78$252 ($add).
  creating $macc model for $add$modulos.v:78$253 ($add).
  creating $macc model for $add$modulos.v:78$257 ($add).
  creating $macc model for $add$modulos.v:78$258 ($add).
  creating $macc model for $add$modulos.v:78$262 ($add).
  creating $macc model for $add$modulos.v:78$263 ($add).
  creating $macc model for $add$modulos.v:81$264 ($add).
  creating $macc model for $add$modulos.v:82$265 ($add).
  creating $macc model for $add$modulos.v:83$266 ($add).
  merging $macc model for $add$modulos.v:78$263 into $add$modulos.v:83$266.
  merging $macc model for $add$modulos.v:78$262 into $add$modulos.v:83$266.
  merging $macc model for $add$modulos.v:78$257 into $add$modulos.v:78$258.
  merging $macc model for $add$modulos.v:78$252 into $add$modulos.v:78$253.
  merging $macc model for $add$modulos.v:78$247 into $add$modulos.v:78$248.
  merging $macc model for $add$modulos.v:78$242 into $add$modulos.v:78$243.
  merging $macc model for $add$modulos.v:78$237 into $add$modulos.v:78$238.
  merging $macc model for $add$modulos.v:78$232 into $add$modulos.v:78$233.
  merging $macc model for $add$modulos.v:78$227 into $add$modulos.v:78$228.
  merging $macc model for $add$modulos.v:78$222 into $add$modulos.v:78$223.
  merging $macc model for $add$modulos.v:78$217 into $add$modulos.v:78$218.
  merging $macc model for $add$modulos.v:78$212 into $add$modulos.v:78$213.
  merging $macc model for $add$modulos.v:78$207 into $add$modulos.v:78$208.
  merging $macc model for $add$modulos.v:78$202 into $add$modulos.v:78$203.
  merging $macc model for $add$modulos.v:78$197 into $add$modulos.v:78$198.
  merging $macc model for $add$modulos.v:78$192 into $add$modulos.v:78$193.
  merging $macc model for $add$modulos.v:78$187 into $add$modulos.v:78$188.
  merging $macc model for $add$modulos.v:78$182 into $add$modulos.v:78$183.
  merging $macc model for $add$modulos.v:78$177 into $add$modulos.v:78$178.
  merging $macc model for $add$modulos.v:78$172 into $add$modulos.v:78$173.
  merging $macc model for $add$modulos.v:78$167 into $add$modulos.v:78$168.
  merging $macc model for $add$modulos.v:78$162 into $add$modulos.v:78$163.
  merging $macc model for $add$modulos.v:78$157 into $add$modulos.v:78$158.
  merging $macc model for $add$modulos.v:78$152 into $add$modulos.v:78$153.
  merging $macc model for $add$modulos.v:78$147 into $add$modulos.v:78$148.
  merging $macc model for $add$modulos.v:78$142 into $add$modulos.v:78$143.
  merging $macc model for $add$modulos.v:78$137 into $add$modulos.v:78$138.
  merging $macc model for $add$modulos.v:78$132 into $add$modulos.v:78$133.
  merging $macc model for $add$modulos.v:78$127 into $add$modulos.v:78$128.
  merging $macc model for $add$modulos.v:78$122 into $add$modulos.v:78$123.
  merging $macc model for $add$modulos.v:78$117 into $add$modulos.v:78$118.
  creating $alu model for $macc $add$modulos.v:81$264.
  creating $alu model for $macc $add$modulos.v:82$265.
  creating $alu model for $macc $add$modulos.v:78$113.
  creating $alu model for $macc $add$modulos.v:78$108.
  creating $macc cell for $add$modulos.v:78$183: $auto$alumacc.cc:354:replace_macc$283
  creating $macc cell for $add$modulos.v:78$238: $auto$alumacc.cc:354:replace_macc$284
  creating $macc cell for $add$modulos.v:78$178: $auto$alumacc.cc:354:replace_macc$285
  creating $macc cell for $add$modulos.v:78$208: $auto$alumacc.cc:354:replace_macc$286
  creating $macc cell for $add$modulos.v:78$173: $auto$alumacc.cc:354:replace_macc$287
  creating $macc cell for $add$modulos.v:78$243: $auto$alumacc.cc:354:replace_macc$288
  creating $macc cell for $add$modulos.v:78$168: $auto$alumacc.cc:354:replace_macc$289
  creating $macc cell for $add$modulos.v:78$218: $auto$alumacc.cc:354:replace_macc$290
  creating $macc cell for $add$modulos.v:78$163: $auto$alumacc.cc:354:replace_macc$291
  creating $macc cell for $add$modulos.v:78$248: $auto$alumacc.cc:354:replace_macc$292
  creating $macc cell for $add$modulos.v:78$158: $auto$alumacc.cc:354:replace_macc$293
  creating $macc cell for $add$modulos.v:78$203: $auto$alumacc.cc:354:replace_macc$294
  creating $macc cell for $add$modulos.v:78$153: $auto$alumacc.cc:354:replace_macc$295
  creating $macc cell for $add$modulos.v:78$253: $auto$alumacc.cc:354:replace_macc$296
  creating $macc cell for $add$modulos.v:78$148: $auto$alumacc.cc:354:replace_macc$297
  creating $macc cell for $add$modulos.v:78$228: $auto$alumacc.cc:354:replace_macc$298
  creating $macc cell for $add$modulos.v:78$143: $auto$alumacc.cc:354:replace_macc$299
  creating $macc cell for $add$modulos.v:78$258: $auto$alumacc.cc:354:replace_macc$300
  creating $macc cell for $add$modulos.v:78$138: $auto$alumacc.cc:354:replace_macc$301
  creating $macc cell for $add$modulos.v:78$198: $auto$alumacc.cc:354:replace_macc$302
  creating $macc cell for $add$modulos.v:78$133: $auto$alumacc.cc:354:replace_macc$303
  creating $macc cell for $add$modulos.v:78$213: $auto$alumacc.cc:354:replace_macc$304
  creating $macc cell for $add$modulos.v:78$128: $auto$alumacc.cc:354:replace_macc$305
  creating $macc cell for $add$modulos.v:78$223: $auto$alumacc.cc:354:replace_macc$306
  creating $macc cell for $add$modulos.v:78$123: $auto$alumacc.cc:354:replace_macc$307
  creating $macc cell for $add$modulos.v:78$188: $auto$alumacc.cc:354:replace_macc$308
  creating $macc cell for $add$modulos.v:78$118: $auto$alumacc.cc:354:replace_macc$309
  creating $macc cell for $add$modulos.v:83$266: $auto$alumacc.cc:354:replace_macc$310
  creating $macc cell for $add$modulos.v:78$233: $auto$alumacc.cc:354:replace_macc$311
  creating $macc cell for $add$modulos.v:78$193: $auto$alumacc.cc:354:replace_macc$312
  creating $alu cell for $add$modulos.v:78$108: $auto$alumacc.cc:474:replace_alu$313
  creating $alu cell for $add$modulos.v:78$113: $auto$alumacc.cc:474:replace_alu$316
  creating $alu cell for $add$modulos.v:82$265: $auto$alumacc.cc:474:replace_alu$319
  creating $alu cell for $add$modulos.v:81$264: $auto$alumacc.cc:474:replace_alu$322
  created 4 $alu and 30 $macc cells.
Extracting $alu and $macc cells in module cargar_datos:
  creating $macc model for $add$modulos.v:19$4 ($add).
  creating $alu model for $macc $add$modulos.v:19$4.
  creating $alu model for $lt$modulos.v:18$3 ($lt): new $alu
  creating $alu cell for $lt$modulos.v:18$3: $auto$alumacc.cc:474:replace_alu$326
  creating $alu cell for $add$modulos.v:19$4: $auto$alumacc.cc:474:replace_alu$331
  created 2 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module comparador_target_hash:
  creating $alu model for $lt$modulos.v:101$268 ($lt): new $alu
  creating $alu model for $lt$modulos.v:101$269 ($lt): new $alu
  creating $alu cell for $lt$modulos.v:101$269: $auto$alumacc.cc:474:replace_alu$336
  creating $alu cell for $lt$modulos.v:101$268: $auto$alumacc.cc:474:replace_alu$341
  created 2 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module generar_W:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module micro_ucr_hash:
  created 0 $alu and 0 $macc cells.

3.12. Executing SHARE pass (SAT-based resource sharing).

3.13. Executing OPT pass (performing simple optimizations).

3.13.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
<suppressed ~1 debug messages>
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.13.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.13.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \algo_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cargar_datos..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparador_target_hash..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \generar_W..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \micro_ucr_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

3.13.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \algo_hash.
  Optimizing cells in module \cargar_datos.
  Optimizing cells in module \comparador_target_hash.
  Optimizing cells in module \generar_W.
  Optimizing cells in module \micro_ucr_hash.
Performed a total of 0 changes.

3.13.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.13.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.13.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..
Removed 32 unused cells and 35 unused wires.
<suppressed ~36 debug messages>

3.13.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.13.9. Rerunning OPT passes. (Maybe there is more to do..)

3.13.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \algo_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cargar_datos..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparador_target_hash..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \generar_W..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \micro_ucr_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

3.13.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \algo_hash.
  Optimizing cells in module \cargar_datos.
  Optimizing cells in module \comparador_target_hash.
  Optimizing cells in module \generar_W.
  Optimizing cells in module \micro_ucr_hash.
Performed a total of 0 changes.

3.13.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.13.13. Executing OPT_RMDFF pass (remove dff with constant values).

3.13.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.13.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.13.16. Finished OPT passes. (There is nothing left to do.)

3.14. Executing FSM pass (extract and optimize FSM).

3.14.1. Executing FSM_DETECT pass (finding FSMs in design).

3.14.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.14.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.14.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.14.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.14.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.14.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.14.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.15. Executing OPT pass (performing simple optimizations).

3.15.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.15.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.15.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.15.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.15.5. Finished fast OPT passes.

3.16. Executing MEMORY pass.

3.16.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

3.16.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.16.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.16.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.16.5. Executing MEMORY_COLLECT pass (generating $mem cells).

3.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.18. Executing OPT pass (performing simple optimizations).

3.18.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
<suppressed ~435 debug messages>
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
<suppressed ~1 debug messages>
Optimizing module generar_W.
Optimizing module micro_ucr_hash.
<suppressed ~6 debug messages>

3.18.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.18.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.18.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..
Removed 0 unused cells and 121 unused wires.
<suppressed ~47 debug messages>

3.18.5. Finished fast OPT passes.

3.19. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

3.20. Executing OPT pass (performing simple optimizations).

3.20.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.20.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.20.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \algo_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cargar_datos..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \comparador_target_hash..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \generar_W..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \micro_ucr_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~2 debug messages>

3.20.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \algo_hash.
  Optimizing cells in module \cargar_datos.
  Optimizing cells in module \comparador_target_hash.
  Optimizing cells in module \generar_W.
  Optimizing cells in module \micro_ucr_hash.
Performed a total of 0 changes.

3.20.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.20.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.20.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

3.20.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.20.9. Finished OPT passes. (There is nothing left to do.)

3.21. Executing TECHMAP pass (map to technology primitives).

3.21.1. Executing Verilog-2005 frontend: <techmap.v>
Parsing Verilog input from `<techmap.v>' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.21.2. Continuing TECHMAP pass.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=32\Y_WIDTH=32 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=32\B_WIDTH=32\Y_WIDTH=32 for cells of type $alu.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $dff.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $not.
Using template $paramod\_90_lcu\WIDTH=32 for cells of type $lcu.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $or.
Using extmapper maccmap for cells of type $macc.
  add $8\x_[7:0] (8 bits, unsigned)
  add \W [63:56] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $9\x_[7:0] (8 bits, unsigned)
  add \W [71:64] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $28\x_[7:0] (8 bits, unsigned)
  add \W [183:176] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $5\x_[7:0] (8 bits, unsigned)
  add \W [39:32] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $32\x_[7:0] (8 bits, unsigned)
  add \W [199:192] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $4\x_[7:0] (8 bits, unsigned)
  add \W [31:24] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $17\x_[7:0] (8 bits, unsigned)
  add \W [135:128] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $30\x_[7:0] (8 bits, unsigned)
  add \W [191:184] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $26\x_[7:0] (8 bits, unsigned)
  add \W [175:168] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $13\x_[7:0] (8 bits, unsigned)
  add \W [103:96] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $16\x_[7:0] (8 bits, unsigned)
  add \W [127:120] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $20\x_[7:0] (8 bits, unsigned)
  add \W [151:144] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $36\x_[7:0] (8 bits, unsigned)
  add \W [215:208] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $15\x_[7:0] (8 bits, unsigned)
  add \W [119:112] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $24\x_[7:0] (8 bits, unsigned)
  add \W [167:160] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $14\x_[7:0] (8 bits, unsigned)
  add \W [111:104] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $6\x_[7:0] (8 bits, unsigned)
  add \W [47:40] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $12\x_[7:0] (8 bits, unsigned)
  add \W [95:88] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $40\x_[7:0] (8 bits, unsigned)
  add \W [231:224] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $11\x_[7:0] (8 bits, unsigned)
  add \W [87:80] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $7\x_[7:0] (8 bits, unsigned)
  add \W [55:48] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $42\x_[7:0] (8 bits, unsigned)
  add \W [239:232] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=6\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
  add $18\x_[7:0] (8 bits, unsigned)
  add \W [143:136] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $10\x_[7:0] (8 bits, unsigned)
  add \W [79:72] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $34\x_[7:0] (8 bits, unsigned)
  add \W [207:200] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add \x_ (8 bits, unsigned)
  add \W [255:248] (8 bits, unsigned)
  add 8'10011111 (8 bits, unsigned)
  add $3\x_[7:0] (8 bits, unsigned)
  add \W [23:16] (8 bits, unsigned)
  add 8'10011001 (8 bits, unsigned)
  add $44\x_[7:0] (8 bits, unsigned)
  add \W [247:240] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $38\x_[7:0] (8 bits, unsigned)
  add \W [223:216] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
  add $22\x_[7:0] (8 bits, unsigned)
  add \W [159:152] (8 bits, unsigned)
  add 8'10100001 (8 bits, unsigned)
Using template $paramod\_90_fa\WIDTH=8 for cells of type $fa.
Using template $paramod\_90_lcu\WIDTH=8 for cells of type $lcu.
Using extmapper simplemap for cells of type $logic_and.
No more expansions possible.
<suppressed ~2316 debug messages>

3.22. Executing OPT pass (performing simple optimizations).

3.22.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
<suppressed ~1238 debug messages>
Optimizing module cargar_datos.
<suppressed ~396 debug messages>
Optimizing module comparador_target_hash.
<suppressed ~20 debug messages>
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.22.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
<suppressed ~15 debug messages>
Finding identical cells in module `\cargar_datos'.
<suppressed ~267 debug messages>
Finding identical cells in module `\comparador_target_hash'.
<suppressed ~24 debug messages>
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 102 cells.

3.22.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.22.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..
Removed 643 unused cells and 1832 unused wires.
<suppressed ~646 debug messages>

3.22.5. Finished fast OPT passes.

3.23. Executing ABC pass (technology mapping using ABC).

3.23.1. Extracting gate netlist of module `\algo_hash' to `<abc-temp-dir>/input.blif'..
Extracted 1972 gates and 2229 wires to a netlist network with 256 inputs and 20 outputs.

3.23.1.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.1.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       50
ABC RESULTS:            ANDNOT cells:      450
ABC RESULTS:              AOI3 cells:       89
ABC RESULTS:              NAND cells:       56
ABC RESULTS:               NOR cells:       92
ABC RESULTS:               NOT cells:      120
ABC RESULTS:              OAI3 cells:       33
ABC RESULTS:                OR cells:       55
ABC RESULTS:             ORNOT cells:       11
ABC RESULTS:              XNOR cells:      222
ABC RESULTS:               XOR cells:      611
ABC RESULTS:        internal signals:     1953
ABC RESULTS:           input signals:      256
ABC RESULTS:          output signals:       20
Removing temp directory.

3.23.2. Extracting gate netlist of module `\cargar_datos' to `<abc-temp-dir>/input.blif'..
Extracted 153 gates and 188 wires to a netlist network with 33 inputs and 32 outputs.

3.23.2.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        1
ABC RESULTS:            ANDNOT cells:       51
ABC RESULTS:               MUX cells:       31
ABC RESULTS:              NAND cells:       15
ABC RESULTS:               NOT cells:       31
ABC RESULTS:                OR cells:       22
ABC RESULTS:              XNOR cells:        1
ABC RESULTS:               XOR cells:       31
ABC RESULTS:        internal signals:      123
ABC RESULTS:           input signals:       33
ABC RESULTS:          output signals:       32
Removing temp directory.

3.23.3. Extracting gate netlist of module `\comparador_target_hash' to `<abc-temp-dir>/input.blif'..
Extracted 105 gates and 138 wires to a netlist network with 32 inputs and 25 outputs.

3.23.3.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.3.2. Re-integrating ABC results.
ABC RESULTS:            ANDNOT cells:       28
ABC RESULTS:              AOI3 cells:        4
ABC RESULTS:              NAND cells:        2
ABC RESULTS:               NOR cells:        5
ABC RESULTS:              OAI3 cells:       10
ABC RESULTS:                OR cells:        1
ABC RESULTS:             ORNOT cells:       14
ABC RESULTS:              XNOR cells:        2
ABC RESULTS:               XOR cells:       12
ABC RESULTS:        internal signals:       81
ABC RESULTS:           input signals:       32
ABC RESULTS:          output signals:       25
Removing temp directory.

3.23.4. Extracting gate netlist of module `\generar_W' to `<abc-temp-dir>/input.blif'..
Extracted 256 gates and 368 wires to a netlist network with 112 inputs and 128 outputs.

3.23.4.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.4.2. Re-integrating ABC results.
ABC RESULTS:            ANDNOT cells:       16
ABC RESULTS:               NOT cells:       32
ABC RESULTS:                OR cells:       96
ABC RESULTS:             ORNOT cells:       16
ABC RESULTS:              XNOR cells:       32
ABC RESULTS:               XOR cells:       96
ABC RESULTS:        internal signals:      128
ABC RESULTS:           input signals:      112
ABC RESULTS:          output signals:      128
Removing temp directory.

3.23.5. Extracting gate netlist of module `\micro_ucr_hash' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.24. Executing OPT pass (performing simple optimizations).

3.24.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

3.24.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

3.24.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..
Removed 0 unused cells and 1366 unused wires.
<suppressed ~5 debug messages>

3.24.5. Finished fast OPT passes.

3.25. Executing HIERARCHY pass (managing design hierarchy).

3.25.1. Analyzing design hierarchy..
Top module:  \micro_ucr_hash
Used module:     \algo_hash
Used module:     \cargar_datos
Used module:     \comparador_target_hash
Used module:     \generar_W

3.25.2. Analyzing design hierarchy..
Top module:  \micro_ucr_hash
Used module:     \algo_hash
Used module:     \cargar_datos
Used module:     \comparador_target_hash
Used module:     \generar_W
Removed 0 unused modules.

3.26. Printing statistics.

=== algo_hash ===

   Number of wires:               1776
   Number of wire bits:           2129
   Number of public wires:           7
   Number of public wire bits:     360
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               1789
     $_ANDNOT_                     450
     $_AND_                         50
     $_AOI3_                        89
     $_NAND_                        56
     $_NOR_                         92
     $_NOT_                        120
     $_OAI3_                        33
     $_ORNOT_                       11
     $_OR_                          55
     $_XNOR_                       222
     $_XOR_                        611

=== cargar_datos ===

   Number of wires:                157
   Number of wire bits:            441
   Number of public wires:           5
   Number of public wire bits:     258
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                215
     $_ANDNOT_                      51
     $_AND_                          1
     $_DFF_P_                       32
     $_MUX_                         31
     $_NAND_                        15
     $_NOT_                         31
     $_OR_                          22
     $_XNOR_                         1
     $_XOR_                         31

=== comparador_target_hash ===

   Number of wires:                 57
   Number of wire bits:            110
   Number of public wires:           4
   Number of public wire bits:      57
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 78
     $_ANDNOT_                      28
     $_AOI3_                         4
     $_NAND_                         2
     $_NOR_                          5
     $_OAI3_                        10
     $_ORNOT_                       14
     $_OR_                           1
     $_XNOR_                         2
     $_XOR_                         12

=== generar_W ===

   Number of wires:                163
   Number of wire bits:            576
   Number of public wires:           3
   Number of public wire bits:     416
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                288
     $_ANDNOT_                      16
     $_NOT_                         32
     $_ORNOT_                       16
     $_OR_                          96
     $_XNOR_                        32
     $_XOR_                         96

=== micro_ucr_hash ===

   Number of wires:                  9
   Number of wire bits:            639
   Number of public wires:           9
   Number of public wire bits:     639
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  4
     algo_hash                       1
     cargar_datos                    1
     comparador_target_hash          1
     generar_W                       1

=== design hierarchy ===

   micro_ucr_hash                    1
     algo_hash                       1
     cargar_datos                    1
     comparador_target_hash          1
     generar_W                       1

   Number of wires:               2162
   Number of wire bits:           3895
   Number of public wires:          28
   Number of public wire bits:    1730
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               2370
     $_ANDNOT_                     545
     $_AND_                         51
     $_AOI3_                        93
     $_DFF_P_                       32
     $_MUX_                         31
     $_NAND_                        73
     $_NOR_                         97
     $_NOT_                        183
     $_OAI3_                        43
     $_ORNOT_                       41
     $_OR_                         174
     $_XNOR_                       257
     $_XOR_                        750

3.27. Executing CHECK pass (checking for obvious problems).
checking module algo_hash..
checking module cargar_datos..
checking module comparador_target_hash..
checking module generar_W..
checking module micro_ucr_hash..
found and reported 0 problems.

4. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
  cell DFFNEGX1 (noninv, pins=3, area=96.00) is a direct match for cell type $_DFF_N_.
  cell DFFPOSX1 (noninv, pins=3, area=96.00) is a direct match for cell type $_DFF_P_.
  cell DFFSR (noninv, pins=5, area=176.00) is a direct match for cell type $_DFFSR_PNN_.
  create mapping for $_DFFSR_PPN_ from mapping for $_DFFSR_PNN_.
  create mapping for $_DFFSR_PNP_ from mapping for $_DFFSR_PNN_.
  create mapping for $_DFFSR_PPP_ from mapping for $_DFFSR_PNP_.
  create mapping for $_DFFSR_NNN_ from mapping for $_DFFSR_PNN_.
  create mapping for $_DFFSR_NPN_ from mapping for $_DFFSR_NNN_.
  create mapping for $_DFFSR_NNP_ from mapping for $_DFFSR_NNN_.
  create mapping for $_DFFSR_NPP_ from mapping for $_DFFSR_NNP_.
  create mapping for $_DFF_NN0_ from mapping for $_DFFSR_NNN_.
  create mapping for $_DFF_NN1_ from mapping for $_DFFSR_NNN_.
  create mapping for $_DFF_NP0_ from mapping for $_DFFSR_NPP_.
  create mapping for $_DFF_NP1_ from mapping for $_DFFSR_NPP_.
  create mapping for $_DFF_PN0_ from mapping for $_DFFSR_PNN_.
  create mapping for $_DFF_PN1_ from mapping for $_DFFSR_PNN_.
  create mapping for $_DFF_PP0_ from mapping for $_DFFSR_PPP_.
  create mapping for $_DFF_PP1_ from mapping for $_DFFSR_PPP_.
  final dff cell mappings:
    DFFNEGX1 _DFF_N_ (.CLK( C), .D( D), .Q( Q));
    DFFPOSX1 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
    DFFSR _DFF_NN0_ (.CLK(~C), .D( D), .Q( Q), .R( R), .S( 1));
    DFFSR _DFF_NN1_ (.CLK(~C), .D( D), .Q( Q), .R( 1), .S( R));
    DFFSR _DFF_NP0_ (.CLK(~C), .D( D), .Q( Q), .R(~R), .S( 1));
    DFFSR _DFF_NP1_ (.CLK(~C), .D( D), .Q( Q), .R( 1), .S(~R));
    DFFSR _DFF_PN0_ (.CLK( C), .D( D), .Q( Q), .R( R), .S( 1));
    DFFSR _DFF_PN1_ (.CLK( C), .D( D), .Q( Q), .R( 1), .S( R));
    DFFSR _DFF_PP0_ (.CLK( C), .D( D), .Q( Q), .R(~R), .S( 1));
    DFFSR _DFF_PP1_ (.CLK( C), .D( D), .Q( Q), .R( 1), .S(~R));
    DFFSR _DFFSR_NNN_ (.CLK(~C), .D( D), .Q( Q), .R( R), .S( S));
    DFFSR _DFFSR_NNP_ (.CLK(~C), .D( D), .Q( Q), .R(~R), .S( S));
    DFFSR _DFFSR_NPN_ (.CLK(~C), .D( D), .Q( Q), .R( R), .S(~S));
    DFFSR _DFFSR_NPP_ (.CLK(~C), .D( D), .Q( Q), .R(~R), .S(~S));
    DFFSR _DFFSR_PNN_ (.CLK( C), .D( D), .Q( Q), .R( R), .S( S));
    DFFSR _DFFSR_PNP_ (.CLK( C), .D( D), .Q( Q), .R(~R), .S( S));
    DFFSR _DFFSR_PPN_ (.CLK( C), .D( D), .Q( Q), .R( R), .S(~S));
    DFFSR _DFFSR_PPP_ (.CLK( C), .D( D), .Q( Q), .R(~R), .S(~S));
Mapping DFF cells in module `\algo_hash':
Mapping DFF cells in module `\cargar_datos':
  mapped 32 $_DFF_P_ cells to \DFFPOSX1 cells.
Mapping DFF cells in module `\comparador_target_hash':
Mapping DFF cells in module `\generar_W':
Mapping DFF cells in module `\micro_ucr_hash':

5. Executing OPT pass (performing simple optimizations).

5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \algo_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \cargar_datos..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \comparador_target_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \generar_W..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \micro_ucr_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \algo_hash.
  Optimizing cells in module \cargar_datos.
  Optimizing cells in module \comparador_target_hash.
  Optimizing cells in module \generar_W.
  Optimizing cells in module \micro_ucr_hash.
Performed a total of 0 changes.

5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\algo_hash'.
Finding identical cells in module `\cargar_datos'.
Finding identical cells in module `\comparador_target_hash'.
Finding identical cells in module `\generar_W'.
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

5.6. Executing OPT_RMDFF pass (remove dff with constant values).

5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \algo_hash..
Finding unused cells or wires in module \cargar_datos..
Finding unused cells or wires in module \comparador_target_hash..
Finding unused cells or wires in module \generar_W..
Finding unused cells or wires in module \micro_ucr_hash..

5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module algo_hash.
Optimizing module cargar_datos.
Optimizing module comparador_target_hash.
Optimizing module generar_W.
Optimizing module micro_ucr_hash.

5.9. Finished OPT passes. (There is nothing left to do.)

6. Executing ABC pass (technology mapping using ABC).

6.1. Extracting gate netlist of module `\algo_hash' to `<abc-temp-dir>/input.blif'..
Extracted 1789 gates and 2045 wires to a netlist network with 256 inputs and 20 outputs.

6.1.1. Executing ABC.
Running ABC command: /usr/lib/qflow/bin/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lib -w /usr/share/qflow/tech/osu018/osu018_stdcells.lib 
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "osu018_stdcells" from "/usr/share/qflow/tech/osu018/osu018_stdcells.lib" has 26 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.01 sec
ABC: Memory =    0.36 MB. Time =     0.01 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + map -M 1 
ABC: + write_blif <abc-temp-dir>/output.blif 

6.1.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:       87
ABC RESULTS:           AOI21X1 cells:      498
ABC RESULTS:           AOI22X1 cells:        8
ABC RESULTS:             INVX1 cells:      621
ABC RESULTS:           NAND2X1 cells:      455
ABC RESULTS:           NAND3X1 cells:      929
ABC RESULTS:            NOR2X1 cells:      250
ABC RESULTS:            NOR3X1 cells:      106
ABC RESULTS:           OAI21X1 cells:      638
ABC RESULTS:             OR2X2 cells:       70
ABC RESULTS:           XNOR2X1 cells:       88
ABC RESULTS:            XOR2X1 cells:       40
ABC RESULTS:        internal signals:     1769
ABC RESULTS:           input signals:      256
ABC RESULTS:          output signals:       20
Removing temp directory.

6.2. Extracting gate netlist of module `\cargar_datos' to `<abc-temp-dir>/input.blif'..
Extracted 183 gates and 216 wires to a netlist network with 33 inputs and 32 outputs.

6.2.1. Executing ABC.
Running ABC command: /usr/lib/qflow/bin/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lib -w /usr/share/qflow/tech/osu018/osu018_stdcells.lib 
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "osu018_stdcells" from "/usr/share/qflow/tech/osu018/osu018_stdcells.lib" has 26 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.36 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + map -M 1 
ABC: + write_blif <abc-temp-dir>/output.blif 

6.2.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:        1
ABC RESULTS:           AOI21X1 cells:       32
ABC RESULTS:             INVX1 cells:       29
ABC RESULTS:           NAND2X1 cells:       30
ABC RESULTS:           NAND3X1 cells:        6
ABC RESULTS:            NOR2X1 cells:       19
ABC RESULTS:            NOR3X1 cells:        3
ABC RESULTS:           OAI21X1 cells:       19
ABC RESULTS:             OR2X2 cells:        2
ABC RESULTS:           XNOR2X1 cells:       10
ABC RESULTS:            XOR2X1 cells:        2
ABC RESULTS:        internal signals:      151
ABC RESULTS:           input signals:       33
ABC RESULTS:          output signals:       32
Removing temp directory.

6.3. Extracting gate netlist of module `\comparador_target_hash' to `<abc-temp-dir>/input.blif'..
Extracted 78 gates and 110 wires to a netlist network with 32 inputs and 25 outputs.

6.3.1. Executing ABC.
Running ABC command: /usr/lib/qflow/bin/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lib -w /usr/share/qflow/tech/osu018/osu018_stdcells.lib 
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "osu018_stdcells" from "/usr/share/qflow/tech/osu018/osu018_stdcells.lib" has 26 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.36 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + map -M 1 
ABC: + write_blif <abc-temp-dir>/output.blif 

6.3.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:        1
ABC RESULTS:           AOI21X1 cells:        7
ABC RESULTS:           AOI22X1 cells:        2
ABC RESULTS:             INVX1 cells:       32
ABC RESULTS:           NAND2X1 cells:       12
ABC RESULTS:           NAND3X1 cells:        2
ABC RESULTS:            NOR2X1 cells:        7
ABC RESULTS:            NOR3X1 cells:       24
ABC RESULTS:           OAI21X1 cells:        6
ABC RESULTS:           OAI22X1 cells:        9
ABC RESULTS:            XOR2X1 cells:        2
ABC RESULTS:        internal signals:       53
ABC RESULTS:           input signals:       32
ABC RESULTS:          output signals:       25
Removing temp directory.

6.4. Extracting gate netlist of module `\generar_W' to `<abc-temp-dir>/input.blif'..
Extracted 288 gates and 400 wires to a netlist network with 112 inputs and 128 outputs.

6.4.1. Executing ABC.
Running ABC command: /usr/lib/qflow/bin/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lib -w /usr/share/qflow/tech/osu018/osu018_stdcells.lib 
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "osu018_stdcells" from "/usr/share/qflow/tech/osu018/osu018_stdcells.lib" has 26 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.01 sec
ABC: Memory =    0.36 MB. Time =     0.01 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + map -M 1 
ABC: + write_blif <abc-temp-dir>/output.blif 

6.4.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:       16
ABC RESULTS:           AOI21X1 cells:       40
ABC RESULTS:             INVX1 cells:       96
ABC RESULTS:           NAND2X1 cells:       45
ABC RESULTS:           NAND3X1 cells:       26
ABC RESULTS:            NOR2X1 cells:       29
ABC RESULTS:           OAI21X1 cells:       41
ABC RESULTS:             OR2X2 cells:       23
ABC RESULTS:           XNOR2X1 cells:       34
ABC RESULTS:            XOR2X1 cells:       12
ABC RESULTS:        internal signals:      160
ABC RESULTS:           input signals:      112
ABC RESULTS:          output signals:      128
Removing temp directory.

6.5. Extracting gate netlist of module `\micro_ucr_hash' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

7. Executing FLATTEN pass (flatten design).
Using template cargar_datos for cells of type cargar_datos.
Using template generar_W for cells of type generar_W.
Using template algo_hash for cells of type algo_hash.
Using template comparador_target_hash for cells of type comparador_target_hash.
<suppressed ~4 debug messages>
No more expansions possible.
Deleting now unused module algo_hash.
Deleting now unused module cargar_datos.
Deleting now unused module comparador_target_hash.
Deleting now unused module generar_W.

8. Executing SETUNDEF pass (replace undef values with defined constants).
Removed 0 unused cells and 2791 unused wires.

9. Executing IOPADMAP pass (mapping inputs/outputs to IO-PAD cells).
Don't map input port micro_ucr_hash.bloque_datos: Missing option -inpad.
Mapping port micro_ucr_hash.bounty using BUFX2.
Don't map input port micro_ucr_hash.clk: Missing option -inpad.
Don't map input port micro_ucr_hash.inicio: Missing option -inpad.
Don't map input port micro_ucr_hash.target: Missing option -inpad.
Mapping port micro_ucr_hash.terminado using BUFX2.

10. Executing OPT pass (performing simple optimizations).

10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module micro_ucr_hash.

10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \micro_ucr_hash..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \micro_ucr_hash.
Performed a total of 0 changes.

10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\micro_ucr_hash'.
Removed a total of 0 cells.

10.6. Executing OPT_RMDFF pass (remove dff with constant values).

10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \micro_ucr_hash..

10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module micro_ucr_hash.

10.9. Finished OPT passes. (There is nothing left to do.)

11. Executing BLIF backend.

12. Printing statistics.

=== micro_ucr_hash ===

   Number of wires:               4215
   Number of wire bits:           4872
   Number of public wires:        4215
   Number of public wire bits:    4872
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               4566
     AND2X2                        105
     AOI21X1                       577
     AOI22X1                        10
     BUFX2                         125
     DFFPOSX1                       32
     INVX1                         778
     NAND2X1                       542
     NAND3X1                       963
     NOR2X1                        305
     NOR3X1                        133
     OAI21X1                       704
     OAI22X1                         9
     OR2X2                          95
     XNOR2X1                       132
     XOR2X1                         56

Warnings: 101 unique messages, 102 total
End of script. Logfile hash: 6606bb09db
CPU: user 3.20s system 0.36s, MEM: 39.75 MB total, 32.18 MB resident
Yosys 0.9 (git sha1 1979e0b)
Time spent: 17% 18x opt_clean (0 sec), 14% 18x opt_expr (0 sec), ...
Running getpowerground to determine power and ground net names.
getpowerground.tcl  /usr/share/qflow/tech/osu018/osu018_stdcells.lef
Cleaning up output syntax
ypostproc.tcl micro_ucr_hash_mapped.blif micro_ucr_hash /usr/share/qflow/tech/osu018/osu018.sh vdd gnd 
Cleaning up blif file syntax
Running blifFanout (iterative)
Each iteration calls:
blifFanout -l 100 -c 20 -I micro_ucr_hash_nofanout -s nullstring -p /usr/share/qflow/tech/osu018/osu018_stdcells.lib -b BUFX2,CLKBUF1 -i A,A -o Y,Y tmp.blif micro_ucr_hash.blif

blifFanout for qflow 1.3.17
Parsing library "osu018_stdcells"
End of library at line 6141
Lib Read:  Processed 6142 lines.
Top internal fanout is 31 (load 550.377) from node _3860_,
driven by INVX1 with strength 58.615 (fF driven at latency 100)
Top fanout load-to-strength ratio is 9.55207 (latency = 955.207 ps)
Top input node fanout is 32 (load 893.552) from node clk.
Warning 1: load of 137.69 is 2.38968 times greater than strongest gate NAND3X1
This warning will only be repeated for larger overload ratios.  Warning count reflects
the total number of overloaded nets.
Warning 17: load of 139.834 is 2.42689 times greater than strongest gate NAND3X1
Warning 152: load of 142.128 is 2.43709 times greater than strongest gate OAI21X1
Warning 208: load of 145.788 is 2.46733 times greater than strongest gate XNOR2X1
Warning 732: load of 151.125 is 2.59136 times greater than strongest gate OAI21X1
Warning 892: load of 155.903 is 2.70577 times greater than strongest gate NAND3X1
Warning 1466: load of 560.377 is 9.72563 times greater than strongest gate NAND3X1
1674 gates exceed specified minimum load.
25 buffers were added.
182 gates were changed.

Gate counts by drive strength:

	"1" gates	In: 4241    	Out: 4059    	-182
	"2" gates	In: 525    	Out: 703    	+178

Number of gates changed: 207
gates resized: 207
blifFanout for qflow 1.3.17
Parsing library "osu018_stdcells"
End of library at line 6141
Lib Read:  Processed 6142 lines.
Top internal fanout is 15 (load 484.909) from node W[0],
driven by DFFPOSX1 with strength 126.421 (fF driven at latency 100)
Top fanout load-to-strength ratio is 3.00404 (latency = 300.404 ps)
Top input node fanout is 10 (load 186.957) from node bloque_datos[80].
Warning 1: load of 494.909 is 2.13677 times greater than strongest gate CLKBUF1
This warning will only be repeated for larger overload ratios.  Warning count reflects
the total number of overloaded nets.
Warning 6: load of 137.69 is 2.38968 times greater than strongest gate NAND3X1
Warning 22: load of 139.834 is 2.42689 times greater than strongest gate NAND3X1
Warning 157: load of 142.128 is 2.43709 times greater than strongest gate OAI21X1
Warning 214: load of 145.788 is 2.46733 times greater than strongest gate XNOR2X1
Warning 740: load of 151.125 is 2.59136 times greater than strongest gate OAI21X1
Warning 843: load of 154.092 is 2.6386 times greater than strongest gate NAND2X1
Warning 900: load of 155.903 is 2.70577 times greater than strongest gate NAND3X1
Warning 1503: load of 389.775 is 3.08314 times greater than strongest gate DFFPOSX1
1688 gates exceed specified minimum load.
0 buffers were added.
22 gates were changed.

Gate counts by drive strength:

	"1" gates	In: 4064    	Out: 4063    	-1
	"2" gates	In: 723    	Out: 703    	-20
	"4" gates	In: 3    	Out: 24    	+21
	"8" gates	In: 1    	Out: 1    	+0

Number of gates changed: 22
gates resized: 22
blifFanout for qflow 1.3.17
Parsing library "osu018_stdcells"
End of library at line 6141
Lib Read:  Processed 6142 lines.
Top internal fanout is 15 (load 484.909) from node W[0],
driven by DFFPOSX1 with strength 126.421 (fF driven at latency 100)
Top fanout load-to-strength ratio is 3.00404 (latency = 300.404 ps)
Top input node fanout is 10 (load 186.957) from node bloque_datos[80].
Warning 1: load of 300.806 is 1.33698 times greater than strongest gate BUFX4
This warning will only be repeated for larger overload ratios.  Warning count reflects
the total number of overloaded nets.
Warning 2: load of 306.536 is 1.36245 times greater than strongest gate BUFX4
Warning 6: load of 494.909 is 2.13677 times greater than strongest gate CLKBUF1
Warning 26: load of 137.69 is 2.38968 times greater than strongest gate NAND3X1
Warning 42: load of 139.834 is 2.42689 times greater than strongest gate NAND3X1
Warning 177: load of 142.128 is 2.43709 times greater than strongest gate OAI21X1
Warning 234: load of 145.788 is 2.46733 times greater than strongest gate XNOR2X1
Warning 760: load of 151.125 is 2.59136 times greater than strongest gate OAI21X1
Warning 863: load of 154.092 is 2.6386 times greater than strongest gate NAND2X1
Warning 920: load of 155.903 is 2.70577 times greater than strongest gate NAND3X1
Warning 1523: load of 389.775 is 3.08314 times greater than strongest gate DFFPOSX1
1708 gates exceed specified minimum load.
0 buffers were added.
0 gates were changed.

Gate counts by drive strength:

	"1" gates	In: 4063    	Out: 4063    	+0
	"2" gates	In: 703    	Out: 703    	+0
	"4" gates	In: 24    	Out: 24    	+0
	"8" gates	In: 1    	Out: 1    	+0

Number of gates changed: 0
gates resized: 0

Generating RTL verilog and SPICE netlist file in directory
	 /home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/synthesis
Files:
   Verilog: /home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/synthesis/micro_ucr_hash.rtl.v
   Verilog: /home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/synthesis/micro_ucr_hash.rtlnopwr.v
   Verilog: /home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/synthesis/micro_ucr_hash.rtlbb.v
   Spice:   /home/isaac/Desktop/Microelectrónica/Proyecto/Parte_2/area_micro_ucr_hash/synthesis/micro_ucr_hash.spc

Running blif2Verilog.
Running blif2BSpice.
Running spi2xspice.py
spi2xspice.py "/usr/share/qflow/tech/osu018/osu018_stdcells.lib" -io_time=1n -time=100p -idelay=10p -odelay=100p -cload=500f micro_ucr_hash.spc micro_ucr_hash.xspice

Synthesis script ended on dom 25 jul 23:36:14 CST 2021
